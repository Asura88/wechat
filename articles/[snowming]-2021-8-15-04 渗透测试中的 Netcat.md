# ❤ 功能1：端口扫描
## 使用场景：
上一篇【网络诊断】里面已经说过了如何使用 nc 判断【单个】端口是否可达。
扩展一下：如果你要测试的不止一个端口，而是某个【范围】的端口。这种行为有个专门的术语叫【端口扫描】。
【端口扫描】是一把双刃剑——“黑帽子”用这招进行信息收集，为后续的入侵做铺垫；“白帽子”用这招来进行“渗透测试”，以排查自己系统中【尚未屏蔽】的对外监听端口。
作为一款牛逼的网络瑞士军刀，nc 当然可以用来干这事儿啦。
顺便说一下：
不论是 TCP 还是 UDP，协议规定的【有效】端口号范围都是：1 ~ 65535。

## 方法：
下面这个命令，用来扫描 IP 地址为 `x.x.x.x` 的主机，扫描的端口范围从 `1` 到 `1024`。
``` bash
nc -znv x.x.x.x 1-1024
```
- 选项 `-z`
意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。
- 选项 `-n`
意为后面接的是IP，无需域名解析。
- 选项 `-v`
显示详细信息。对 nc 的其它用法，-v 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果。

## 实验：
**实验环境：**

- Windows 10 主机

![title](https://leanote.com/api/file/getImage?fileId=5d9edcd2ab64415c47000ab3)

- Kali 主机

![title](https://leanote.com/api/file/getImage?fileId=5d9edd0eab64415c47000ab7)

**实验：**

Windows扫Kali的1-1024端口：

![title](https://leanote.com/api/file/getImage?fileId=5d9edd22ab64415a49000b68)

Kali扫Windows：

![title](https://leanote.com/api/file/getImage?fileId=5d9edd34ab64415c47000ab8)

实测速度有点慢，但是 nmap 也很慢嘛，所以我还是最喜欢 masscan。但是因为 nc 是自带的，所以这种【端口扫描】特别适合在当前环境没有 nmap 或者 masscan 的时候使用，用来进行端口/服务信息收集。


## 补充说明：优化输出
`注意：`这一部分摘抄自「编程随想」的原博客，亲测没用。但是可能是 nc 变种与主机环境的问题，所以也抄在这里。为什么没用呢？就比如他提到了 `grep succeeded`，但是从上面的截图可以看出，根本没有 `succeeded` 这个词出现，所以最多只能 `grep open`。
>玩“端口扫描”的时候，“-v 选项”会把“成功/失败”的结果统统打印出来。
通常大伙儿关注的都是“扫描成功”的那些端口。因此，可以用如下命令过滤一下，只打印扫出来的端口。
``` bash
nc -znv x.x.x.x 1-1024  2>&1 | grep succeeded
```
>由于“-v 选项”产生的输出位于【stderr】，**上述命令中的 2>&1 用来把【stderr】合并到【stdout】**（注：这种写法只适用于 POSIX 系统上的 shell）
grep 命令用来进行【过滤】。对于 Windows 系统，默认【没有】grep 命令，需改用 find 命令过滤。

## 补充说明：超时设置
如果你要扫描的端口范围，跨度比较大，超时值要【恰到好处】—— 超时值太大，会浪费时间；超时值太小，可能会遗漏某些端口（端口本身开放，但 nc 还没来得及连上就超时了）
如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加`-w` 选项，设置一个比较小的超时值。`注：` 【-w】的单位为秒。
比如你心理觉得30分钟扫不出来就算了，那么就设置一个 `-w 1800`。
但是一般情况下，可以不设置超时，宁可浪费一些时间，也要保持扫描结果的完整性。

## 补充说明：【并发】扫描
如果你设置了较小的超时值，依然嫌慢，还可以用【并发】扫描的方式，进一步提升效率。
简而言之，【并发扫描】就是：**同时运行多个 nc，分别扫描不同的端口范围。**

nc 并发端口扫描：

![title](https://leanote.com/api/file/getImage?fileId=5d9edd73ab64415a49000b6c)

# ❤ 功能2：【信息收集】用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）
## 使用场景：
入侵者在发起攻击之前，有一个很重要的步骤叫做【信息收集】。攻击者对目标了解得越多，得手的机会就越大。
下面以 SSH Server（sshd）举例。

## 方法：
如今要【远程管理】服务器，最常用的大概就是 SSH 这种方式了。
如果某个服务器运行了 SSH 服务端（默认监听端口是 22），那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。
``` bash
echo "EXIT" | nc -vq 5 -n 服务器IP 22
echo "EXIT" | nc -vq 5 服务器域名 22
```
- echo 命令
上述用到的 echo 命令是 POSIX 下常用的命令。Windows 的命令行中也有同名的命令，但功能/用法有【差异】。
这里使用 echo 的主要原因是：如果使用了这条 echo 指令，会在延时时间之后自动退出，否则则会一直停在光标闪动的状态不退出。

- 选项 `-v` 详细信息
玩这招时，最好加`-v`选项（详细信息）——nc 会先显示“端口已经连上”或者“端口连不上”。

- 选项 `-q` 延时退出
主要考虑到：当用 nc 去连接一些位于【公网】上的 Web Server时，考虑到网络环境的诸多因素，最好加 `-q` 选项，让 nc【延时】退出。`-q` 的单位为秒。实际操作时，要根据网络环境调整 `-q` 的选项值。

- 选项 `-n` 【不进行】域名解析
当使用 nc 直接连接 IP 而不是域名时候，要加上这一命令行选项。

## 实验：

现在有这样一个开启了 SSH 服务的公网VPS：
![title](https://leanote.com/api/file/getImage?fileId=5d9edda8ab64415a49000b6f)

**实验1：使用 nc 探测其 SSH 端口：**
探测 SSH 端口：
![title](https://leanote.com/api/file/getImage?fileId=5d9eddc2ab64415c47000ab9)

这样就获取了该VPS的操作系统类型为Ubuntu，以及其SSH server的版本。最后出现了一行报错，可能是因为我的VPS把SSH服务端开启在非默认监听端口（port 22）。当然也可以看出，netcat 判断某个端口服务的方式非常简单粗暴，是匹配某个服务的默认端口。


**实验2：使用 nc 探测某台内网主机的3389端口：**
探测 3389：
![title](https://leanote.com/api/file/getImage?fileId=5d9edddcab64415a49000b72)

没有探测成功具体的服务信息或操作系统信息，只是连接成功了。
此图可以看出加与不加 `echo语句` 的区别。

**实验3：使用 nc 探测 Github 的 SSH 端口：**
探测 Github 的 SSH 端口：
![title](https://leanote.com/api/file/getImage?fileId=5d9ede00ab64415c47000abc)
如果说明 `-q` 有风险，可能还没来得及抓到信息就延时退出了。

到这里我想到不会之前抓不到 3389 远程桌面的服务信息是因为提前延时退出了吧，但是回去试了下并不是，就是获取不到：
去掉【-q】参数 nc 3389：
![title](https://leanote.com/api/file/getImage?fileId=5d9ede1dab64415c47000abd)


## 补充说明：批处理＆自动化
某些“有心人”甚至可以搞一个脚本，批量探测某个 IP 地址段的 22 端口，然后把找到的服务器信息保存在某个文件中。
另外，有的系统管理员会把 sshd 的监听端口从 22 改为其它数值，想要迷惑攻击者。但这么干，【效果不大】。
攻击者可以先进行端口扫描，拿到所有已开启的 TCP 监听端口；然后利用上述方法，对这些 TCP 端口进行【自动化】探测，从而判断出哪个端口是 SSH Server。

## 补充说明：防范措施
本章节以“SSH Server”举例来说明入侵者如何探测服务端的软件版本。
除了“SSH Server”，很多其它的服务端软件，也存在类似的【信息暴露】。
一个谨慎的系统管理员，应该通过定制，【消除 or 伪造】这些信息，从而增加入侵者的攻击成本。

# ❤ 功能3：【隐匿性】用 nc 实现【彻底无痕】的 Web 访问
## 使用场景：
有时候，想要看某个 Web 服务器上的某个页面的内容，但是又【不希望】在那上面留下我本人的任何痕迹。这里所说的“痕迹”既包括【网络】层面，也包括【操作系统 ＆ 软件】层面。
要搞定【网络】层面，主要靠【暗网】（Tor or I2P），来掩盖【真实】“公网 IP”。
要搞定【操作系统 ＆ 软件】层面，稍微麻烦一点。如果你用传统的浏览器（Chrome、Firefox、IE、Edge ...）访问了某个页面。即使你禁用了 JS，伪造了浏览器的“User Agent”。但如果 Web 服务器想要收集你的系统指纹，还是有若干办法——可以通过浏览器的一些差异，获得某些信息量（安全行话叫做“浏览器指纹”）。
比如说：HTTP 协议的【Header】字段可能会包含某些信息。
比如说：不同内核的浏览器，对页面的渲染会有差异。对页面中的【外部】元素（图片、JS、CSS ...）的加载效率也会有差异。
比如说：即使同一款浏览器，在不同系统平台上，依然会表现出某些差异。
......
此时，nc 再度派上用场——你可以用 nc 直接抓取页面，保存到本机。
这种玩法相当于——让 nc 在【裸 TCP】层面执行 HTTP 协议的命令。在整个过程中，浏览器完全【不】参与其中。既【不会】暴露浏览器的信息，也【不会】暴露操作系统的信息。

## 方法：
先执行下列两个命令的其中一个（具体看你想用“IP”还是“域名”）：
``` bash
echo -e "GET / HTTP/1.0\r\n\r\n" | nc -vq 5 服务器域名 端口
echo -e "GET / HTTP/1.0\r\n\r\n" | nc -vq 5 -n 服务器IP 端口
```
由于正常人类是无法直接阅读【HTML 源代码】的。为了更加人性化，可以把 nc 抓下来的 HTML 源代码重定向到某个 HTML 文件，然后就可以用本机的浏览器阅读之。

- 选项 `-q`
即为【延时退出】。

## 实验：

nc 访问百度（绕过了浏览器）：

![title](https://leanote.com/api/file/getImage?fileId=5d9ede53ab64415c47000abf)


把访问百度的结果重定向到桌面的 1.html 文件：

![title](https://leanote.com/api/file/getImage?fileId=5d9ede63ab64415c47000ac0)


1.html：

![title](https://leanote.com/api/file/getImage?fileId=5d9edf80ab64415c47000ac6)

## 补充说明：这种方式的【缺点】
为什么上面看到的百度页面和正常百度有所不同呢？

- nc 不抓取“页面的【外部】元素”
用这招，nc 只抓取页面本身，不包括页面中的外部元素（图片、JS、CSS ...）。
这种方式拿到的页面，阅读的时候会显得比较丑陋（就凑合着看吧）。

- 关于“JS 引擎”
由于这招只是在 TCP 层面模拟了简单的 HTTP 协议。所以只能得到【静态 HTML】。
如果某个页面的内容是依靠【前端 JS】动态生成（所谓的 AJAX 风格），那这招就不灵啦（因为 nc【没有】JS 引擎）。

### 补充说明：HTTP 协议
- 协议版本
有些同学会奇怪——为什么上述的示例用的是 1.0 而不是 1.1？
主要是为了偷懒——按照 RFC 的规范，HTTP 1.1 的 Request 中，Host 是【必须】的字段；而在 HTTP 1.0 中，这个字段是【可选】滴。

- HTTPS
nc 的“OpenBSD 变种”还【不】支持 HTTPS（SSL/TLS）。
在 nc 的变种中，ncat ＆ socat（最强大的 nc 变种，几乎是一个新的软件了）已经完全支持 SSL/TLS 协议。
由于本文主要介绍 nc 的“OpenBSD 变种”，关于 ncat ＆ socat 的话题，不作过多展开。


-----------

参考链接：
[1] [扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵”](https://program-think.blogspot.com/2019/09/Netcat-Tricks.html)，Program Thinking，2019年9月18日
[2] [linux netcat命令使用技巧](https://www.cnblogs.com/lpfuture/p/5719066.html)，博客园，2016年7月29日
