#  美国NSA超级后门Bvp47的隐身技能：网络隐身2

原创 debugeeker [ debugeeker ](javascript:void\(0\);)

**debugeeker** ![]()

微信号 gh_ed0f7fa0bfe0

功能介绍 安全攻防技术 大厂经历分享 程序员职业规划

____

___发表于_

收录于合集

#Linux内核 4 个

#后门 4 个

#恶意软件 18 个

#美国 3 个

#防火墙 1 个

  

> 本文是基于Bvp47技术报告(PDF)和`Linux`内核写的。
>
> 这篇主要是讲述`Bvp47`在网络侧的隐身

前面已经讲了`Bvp47`通过挂钩各种内核`socket`函数，从而在主机侧完美隐身。

但恶意软件一般是要相互通信的，相互通信就意味着一个节点可以连接到另外一个节点的端口。

那么，如果扫描一台机器所有端口，找出哪些开启的端口，和目标主机侧找出监听的端口，是可以知道被隐藏的端口的，从而知道目标主机是否感染了恶意软件。

那么，`Bvp47`是通过什么方式逃过扫描器的检测呢？

从《`Bvp47`技术报告》可知，`Bvp47`使用了一种 **端口敲门** 技术。

那么， **端口敲门** 技术是怎样的呢？

 **端口敲门** 是通过向目标机器发送特定序列的数据包，当这个序列匹配时，目标机器就会对该源IP打开指定的端口，接受它的连接，从而相互通信。

按照这个技术描述，假设22端口打开需要敲门数据包满足一定序列，序列每项需要源端口，宿端口和标志位都要是特定值。由于端口范围是0-65535，标志位有9种，那么，当该序列只有一个元素时，一个扫描器要扫出目标机器开启了22端口，按照我机器上`nmap`扫描65535个端口要5.21秒的速度来算，需要扫上35天才能够扫出22端口，每增加一个元素，需要的天数就是35*(65536
_65536_ 9)^(n-1)。

即使，序列只有一个元素，`nmap`要发现目标机器所有端口，都要35*65536/365=6284年的时间。

而`Bvp47`呢，用了一个序列包，而包里还有136字节的数据。那么，一个扫描器要能够发现它的存在，需要花上2.2亿年。

从这个角度来说，`Bvp47`从网络上隐身了。

  

预览时标签不可点

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。   视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看

